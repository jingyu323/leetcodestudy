package rain.test.study20200112;

/**
 * 广度优先遍历（BFS）
 * <p>
 * 它是一个分层搜索的过程和二叉树的层次遍历十分相似，
 * 它也需要一个队列以保持遍历过的顶点顺序，
 * 以便按出队的顺序再去访问这些顶点的邻接顶点
 * <p>
 * 问题：
 * 怎么确定下一个节点不是邻接点
 * <p>
 * 基本思想：
 * 1.顶点V入队列
 * 2.当 队列非空的时候则继续执行，否则结束
 * 3. 出队列取得队列顶点头 访问病标记顶点V已经被访问过
 * 4.查找顶点V的另外一个节点col，
 * 5.若V的col（自己理解列，后续再看） 邻接点没有被访问入队列
 * 6.继续查找顶点V的另一个新的节点
 * <p>
 * 伪代码：
 * 初始化队列Q；visited[n]=0；
 * 2）访问顶点v；visited[v]=1；顶点v入队列Q；
 * 3）while（队列Q非空）
 * v=队列Q的对头元素出队；
 * w=顶点v的第一个邻接点；
 * while（w存在）
 * 如果w未访问，则访问顶点w；
 * visited[w]=1；
 * 顶点w入队列Q；
 * w=顶点v的下一个邻接点。
 */

public class GraphBfs {

}
